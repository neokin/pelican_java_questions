
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="/theme/stylesheet/style.min.css">


    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
          href="/theme/pygments/github.min.css">

    <script src="/theme/tipuesearch/jquery.min.js"></script>
    <script src="/theme/tipuesearch/tipuesearch.min.js"></script>
    <script src="/theme/tipuesearch/tipuesearch.min.js"></script>
    <script src="/theme/tipuesearch/tipuesearch_set.min.js"></script>
    <script src="/tipuesearch_content.js"></script>
    <link rel="stylesheet" href="/theme/tipuesearch/tipuesearch.min.css" />

  <link rel="stylesheet" type="text/css" href="/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="/theme/font-awesome/css/solid.css">


    <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Java Interview Atom">



  


    <meta name="author" content="Кирилл" />
    <meta name="description" content="" />
<meta property="og:site_name" content="Java Interview"/>
<meta property="og:type" content="blog"/>
<meta property="og:title" content="Java Interview"/>
<meta property="og:description" content=""/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content=""/>



  <title>Java Interview &ndash; JVM</title>

</head>
<body class="light-theme">
  <aside>
    <div>
      <a href="">
        <img src="/theme/img/profile.png" alt="" title="">
      </a>

      <h1>
        <a href=""></a>
      </h1>


        <form class="navbar-search" action="/search.html" role="search">
          <input type="text" name="q" id="tipue_search_input" placeholder="Search...">
        </form>

      <nav>
        <ul class="list">


              <li>
                <a target="_self"
                   href="/pages/java-core.html#java-core">
                  Java Core
                </a>
              </li>
              <li>
                <a target="_self"
                   href="/pages/java-collections-framework.html#java-collections-framework">
                  Java Collections Framework
                </a>
              </li>
              <li>
                <a target="_self"
                   href="/pages/java-8.html#java-8">
                  Java 8
                </a>
              </li>
              <li>
                <a target="_self"
                   href="/pages/oop.html#oop">
                  ООП
                </a>
              </li>
              <li>
                <a target="_self"
                   href="/pages/shablony-proektirovaniia.html#shablony-proektirovaniia">
                  Шаблоны проектирования
                </a>
              </li>
              <li>
                <a target="_self"
                   href="/pages/jvm.html#jvm">
                  JVM
                </a>
              </li>
              <li>
                <a target="_self"
                   href="/pages/mnogopotochnost.html#mnogopotochnost">
                  Многопоточность
                </a>
              </li>
              <li>
                <a target="_self"
                   href="/pages/serializatsiia.html#serializatsiia">
                  Сериализация
                </a>
              </li>
              <li>
                <a target="_self"
                   href="/pages/bazy-dannykh.html#bazy-dannykh">
                  Базы данных
                </a>
              </li>
              <li>
                <a target="_self"
                   href="/pages/sql.html#sql">
                  SQL
                </a>
              </li>
              <li>
                <a target="_self"
                   href="/pages/osnovy-web.html#osnovy-web">
                  Основы Web
                </a>
              </li>
              <li>
                <a target="_self"
                   href="/pages/xml.html#xml">
                  XML
                </a>
              </li>
              <li>
                <a target="_self"
                   href="/pages/servlets-jsp-jstl.html#servlets-jsp-jstl">
                  Servlets, JSP, JSTL
                </a>
              </li>
              <li>
                <a target="_self"
                   href="/pages/zhurnalirovanie.html#zhurnalirovanie">
                  Журналирование
                </a>
              </li>
              <li>
                <a target="_self"
                   href="/pages/testirovanie.html#testirovanie">
                  Тестирование
                </a>
              </li>
              <li>
                <a target="_self"
                   href="/pages/jdbc.html#jdbc">
                  JDBC
                </a>
              </li>
              <li>
                <a target="_self"
                   href="/pages/potoki-vvodavyvoda-v-java.html#potoki-vvodavyvoda-v-java">
                  Потоки ввода/вывода в Java
                </a>
              </li>

        </ul>
      </nav>

      <ul class="social">
      </ul>
    </div>

  </aside>
  <main>


<article class="single">
  <header>
    
    <h1 id="jvm">JVM</h1>
  </header>
  <div>
<h3 id="_"><a name="jvm"></a>_</h3>
<ul>
<li><a href="#За-что-отвечает-JVM">За что отвечает JVM</a></li>
<li><a href="#Classloader">Classloader</a></li>
<li><a href="#Области-данных-времени-выполнения">Области данных времени выполнения</a></li>
<li><a href="#Frames">Frames</a></li>
<li><a href="#Execution-Engine">Execution Engine</a></li>
<li><a href="#Полезные-ссылки">Полезные ссылки</a></li>
</ul>
<h3 id="jvm"><a name="За-что-отвечает-JVM"></a>За что отвечает <em>JVM</em>:</h3>
<ul>
<li>Загрузка, проверка и исполнение байт кода;</li>
<li>Предоставление среды выполнения для выполнения байт-кода;</li>
<li>Управление памятью и очисткой мусора (Garbage collection);</li>
</ul>
<p>Виртуальная машина Java (Java Virtual Machine) - это механизм, предоставляющий среду выполнения для управления Java-кодом или приложениями.
Виртуальная машина является независимой оболочкой исполнения кода, благодаря которой возможен её запуск на любой ОС,
без влияния ОС на выполняемую программу. </p>
<p>JVM работает с 2мя типами данных:  примитивные типы (<strong>primitive types</strong>) и ссылочные типы (<strong>reference types</strong>).</p>
<p><strong>Примитивы</strong></p>
<p>JVM работает с примитивными значениями (целыми числами и числами с плавающей точкой). По сути, JVM - это 32-битная машина. 
Типы <code>long</code> и <code>double</code>, которые являются 64-битными, поддерживаются изначально, но занимают две единицы памяти в <code>frame's local</code> 
или стеке операндов, поскольку каждая единица составляет 32 бита.
Типы <code>boolean</code>, <code>byte</code>, <code>short</code> и <code>char</code> имеют расширенный знак (кроме <code>char</code> с нулевым расширением) и работают как 32-разрядные целые числа, так же, как и типы <code>int</code>.
Меньшие типы имеют только несколько специфических для типа инструкций для загрузки, хранения и преобразования типов.
<code>boolean</code> значение работает как 8-битное <code>byte</code> значения, где 0 представляет значение <strong>false</strong>, а 1 - значение <strong>true</strong>.</p>
<p><strong>Типы ссылок и значения</strong></p>
<p>Существует три типа ссылочных типов: типы классов, типы массивов и типы интерфейсов.
Их значения являются ссылками на динамически создаваемые экземпляры классов, массивы или экземпляры классов, 
которые реализуют интерфейсы соответственно.</p>
<p><a href="#jvm">к оглавлению</a></p>
<h3 id="classloader"><a name="Classloader"></a>Classloader</h3>
<p>Загрузчик классов является частью JRE, которая динамически закгружает Java классы в JVM. 
Обычно классы загружаются только по запросу. Система исполнения в Java не должна знать о файлах и файловых системах
благодаря загрузчику классов. <strong>Делегирование является важной концепцией</strong>, которую выполняет загрузчик. Загрузчик классов 
отвечает за поиск библиотек, чтение их содержимого и загрузку классов, содержащихся в библиотеках. 
Эта <strong>загрузка</strong> обычно выполняется <strong>«по требованию»</strong>, поскольку она не происходит до тех пор, пока программа не вызовет класс.
<strong>Класс с именем может быть загружен только один раз данным загрузчиком классов.</strong></p>
<p>При запуске JVM, используются три загрузчика классов:
* Bootstrap class loader (Загрузчик класса Bootstrap)
* Extensions class loader (Загрузчик класса расширений)
* System class loader (Системный загрузчик классов)</p>
<p><strong>Загрузчик класса Bootstrap</strong> загружает основные библиотеки Java, расположенные в папке <code>&lt;JAVA_HOME&gt;/jre/lib</code>. 
Этот загрузчик является частью ядра JVM, написан на нативном коде.</p>
<p><strong>Загрузчик класса расширений</strong> загружает код в каталоги расширений 
(<code>&lt;JAVA_HOME&gt;/jre/lib/ext</code>, или любой другой каталог, указанный системным свойством <code>java.ext.dirs</code>).</p>
<p><strong>Системный загрузчик</strong> загружает код, найденный в <code>java.class.path</code>, который сопоставляется с переменной среды <code>CLASSPATH</code>.
Это реализуется классом <code>sun.misc.Launcher$AppClassLoader</code>.</p>
<p>Загрузчик классов выполняет три основных действия в строгом порядке: 
* Загрузка: находит и импортирует двоичные данные для типа. 
* Связывание: выполняет проверку, подготовку и (необязательно) разрешение. 
    - Проверка: обеспечивает правильность импортируемого типа. 
    - Подготовка: выделяет память для переменных класса и инициализация памяти значениями по умолчанию. 
    - Разрешение: преобразует символические ссылки из типа в прямые ссылки. 
* Инициализация: вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.</p>
<p><strong>Пользовательский загрузчик классов</strong></p>
<p>Загрузчик классов написан на Java. Поэтому возможно создать свой собственный загрузчик классов, не понимая тонких деталей JVM.
У каждого загрузчика классов Java есть родительский загрузчик классов, определенный при создании экземпляра нового 
загрузчика классов или в качестве системного загрузчика классов по умолчанию для виртуальной машины.</p>
<p>Что делает возможным следующее:
* загружать или выгружать классы во время выполнения (например, динамически загружать библиотеки во время выполнения, даже из ресурса HTTP).
Это важная особенность для:
    - реализация скриптовых языков;
    - использование bean builders;
    - добавить пользовательскую расширение;
    - позволяя нескольким пространствам имен общаться. Например, это одна из основ протоколов CORBA / RMI;
* изменить способ загрузки байт-кода (например, можно использовать зашифрованный байт-код класса Java);
* модифицировать загруженный байт-код (например, для переплетения аспектов во время загрузки при использовании аспектно-ориентированного программирования);</p>
<p><a href="#jvm">к оглавлению</a></p>
<h3 id="_1"><a name="Области-данных-времени-выполнения"></a>Области данных времени выполнения</h3>
<p>Run-Time Data Areas. JVM выделяет множество областей данных во время выполнения, к-рые используются во время выполнения программы. Некоторые участки данных
созданы JVM во время старта и уничтожаются во время её выключения. Другие создаются для каждого потока и уничтожаются, когда поток уничтожается.</p>
<p><strong>The pc Register (PCR)</strong></p>
<p>Виртуальная машина Java может поддерживать много потоков исполнения одновременно. Каждый поток виртуальной машины Java имеет свой собственный регистр PC (programm counter).
В любой момент каждый поток виртуальной машины Java выполняет код одного метода, а именно текущий метод для этого потока.
Если этот метод не является native, регистр pc содержит адрес инструкции виртуальной машины Java, выполняемой в настоящее время.</p>
<p>Коротко говоря: для одного потока существует один PCR, который создается при запуске потока. PCR хранит адрес выполняемой сейчас инструкции JVM.</p>
<p><strong>Java Virtual Machine Stacks</strong></p>
<p>Каждый поток в JVM имеет собственный стек, созданный одновременно с потоком.  Стек в JVM хранит frames. 
Cтеки в JVM могут иметь фиксированный размер или динамически расширяться и сжиматься в соответствии с требованиями вычислений.</p>
<p><strong>Heap</strong></p>
<p>JVM имеет heap (кучу), которая используется всеми потоками виртуальной машины Java. 
Куча - это область данных времени выполнения, из которой выделяется память для всех экземпляров и массивов классов.
Куча создается при запуске виртуальной машины. Хранилище для объектов восстанавливается автоматической системой 
управления данными (известной как сборщик мусора); объекты никогда не освобождаются явно. 
JVM не предполагает какого-либо конкретного типа системы автоматического управления хранением данных, 
и метод управления может быть выбран в соответствии с системными требованиями разработчика. 
Куча может иметь фиксированный размер или может быть расширена в соответствии с требованиями вычислений и может быть сокращена, 
если большая куча становится ненужной. Память для кучи не должна быть смежной.</p>
<p><strong>Method Area</strong></p>
<p>JVM имеет область методов, которая является общей для всех потоков. Она хранит структуры для каждого класса, такие как пул констант, данные полей и методов, 
а также код для методов и конструкторов, включая специальные методы, используемые при инициализации классов и экземпляров, и инициализации интерфейса.
Хотя область метода является логически частью кучи, простые реализации могут не обрабатываться собиращиком мусора. Область метода может иметь 
фиксированный размер или может быть расширена в соответствии с требованиями вычислений и может быть сокращена, если большая область метода становится ненужной.</p>
<p><strong>Run-Time Constant Pool</strong></p>
<p>A run-time constant pool существует для каждого класса или интерфейса в рантайме и представленно constant_pool таблицей в *.class файле.
 Он содержит несколько видов констант: от числовых литералов, известных во время компиляции, до ссылок на методы и поля, 
 которые должны быть разрешены во время выполнения.  Сам run-time constant pool выполняет функцию,
 аналогичную функции таблицы символов для обычного языка программирования, хотя он содержит более широкий диапазон данных, чем типичная таблица символов.
 Каждый run-time constant pool отделён от JVM's method area. JVM создаёт run-time constant pool вместе с созданием class или interface.</p>
<p><strong>Native Method Stacks</strong></p>
<p>Реализация виртуальной машины Java может использовать обычные стеки, обычно называемые «стеки Си», для поддержки native methods (методов, написанных на языке, отличном от языка программирования Java).</p>
<p><a href="#jvm">к оглавлению</a></p>
<h3 id="frames"><a name="Frames"></a>Frames</h3>
<p>Frame используется для хранения данных и частичных результатов, а также для выполнения динамического связывания, возврата значений для методов и отправки исключений.
Новый frame создается каждый раз, когда вызывается метод. Frame уничтожается, когда завершается вызов метода, 
является ли это завершение нормальным или резким (он генерирует неперехваченное исключение). Frames выделяются из стека потока, создающего frame. 
Каждый frame имеет свой собственный массив локальных переменных, свой собственный стек операндов и ссылку на пул констант во время выполнения класса текущего метода.
Размеры массива локальных переменных и стека операндов определяются во время компиляции и предоставляются вместе с кодом для метода, связанного с фреймом.
Таким образом, размер структуры данных, frame-а зависит только от реализации виртуальной машины Java, и память для этих структур может быть выделена одновременно при вызове метода.</p>
<p>Только один frame активен в любой точке данного потока управления - метода выполнения, и это frame называется текущим, а его метод известен как текущий метод.
Класс, в котором определен текущий метод, является текущим классом. Операции над локальными переменными и стеком операндов обычно выполняются со ссылкой на текущий frame.</p>
<p>Frame перестает быть текущим, если его метод вызывает другой метод или если его метод завершается. Когда метод вызывается, новый frame создается и становится текущим, 
когда управление переходит к новому методу. При возврате метода текущий frame передает результат вызова метода, если таковой имеется, в предыдущий frame. 
Текущий frame затем отбрасывается, так как предыдущий frame становится текущим. Обратите внимание, что frame, созданный потоком, 
является локальным для этого потока и на него не может ссылаться ни один другой поток.</p>
<p><strong>Локальные переменные</strong></p>
<p>Каждый frame содержит массив переменных, известных как его локальные переменные. Длина массива локальных переменных frame определяется во время компиляции 
и предоставляется в двоичном представлении класса или интерфейса вместе с кодом для метода, связанного с frame-ом.
Еденичная локальная переменная может хранить значение типа: boolean, byte, char, short, int, float, reference, or returnAddress. 
Пара локальных переменных может хранить значение типов: long или double.</p>
<p>Локальные переменные адресуются путем индексации. Индекс первой локальной переменной равен нулю.</p>
<p>Значение типа long или типа double занимает две последовательные локальные переменные.</p>
<p>JVM использует локальные переменные для передачи параметров при вызове метода. При вызове метода класса все параметры передаются в последовательных локальных переменных, 
начиная с локальной переменной 0. При вызове метода экземпляра локальная переменная 0 всегда используется для передачи ссылки на объект,
для которого вызывается метод экземпляра (this в Java). Любые параметры впоследствии передаются в последовательных локальных переменных, начиная с локальной переменной 1.</p>
<p><strong>Стеки операндов (Operand Stacks)</strong></p>
<p>Каждый frame содержит стек «последний вошел - первый вышел» (LIFO), известный как стек операндов. Максимальная глубина стека операндов frame-a
определяется во время компиляции и предоставляется вместе с кодом для метода, связанного с frame-ом.</p>
<p>Стек операнда пуст при создании frame-a, который его содержит. JVM предоставляет инструкции для загрузки констант 
или значений из локальных переменных или полей в стек операндов. Другие инструкции JVM берут операнды из стека операндов, 
оперируют с ними и помещают результат обратно в стек операндов. Стек операндов также используется для подготовки параметров 
для передачи в методы и для получения результатов метода.</p>
<p>Для примера, инструкция <strong>iadd</strong>  суммирует два int-вых значения. От стека операндов требуется, чтобы два int-вых значения были наверху стека.
Значения удаляются из стека, операция <strong>pop</strong>. Суммируются и их сумма помещается в стек операндов.</p>
<p><strong>Динамическое связывание (Dynamic Linking)</strong></p>
<p>Каждый frame содержит ссылку на  run-time constant pool для типа текущего метода для поддержки динамического связывания кода метода.
Доступ к вызываемым методам и переменным осуществляется через символические ссылки из class файла.
Динамическое связывание преобразует эти символьные ссылки на методы в конкретные ссылки на методы, загружая классы по мере необходимости 
для разрешения пока еще не определенных символов, и преобразует обращения к переменным в соответствующие смещения в структурах хранения, 
связанных с расположением этих переменных во время выполнения.</p>
<p>Позднее связывание методов и переменных вносит изменения в другие классы, которые метод использует с меньшей вероятностью нарушить этот код.</p>
<p><strong>Нормальное завершение вызова метода</strong></p>
<p>Вызов метода завершается нормально, если этот вызов не вызывает исключение, либо непосредственно из JVM, либо в результате выполнения явного оператора throw. 
Если вызов текущего метода завершается нормально, то значение может быть возвращено вызывающему методу. 
Это происходит, когда вызванный метод выполняет одну из инструкций возврата, выбор которых должен соответствовать типу возвращаемого значения (если оно есть).</p>
<p>Текущий frame используется в этом случае для восстановления состояния инициатора, включая его локальные переменные и стек операндов, 
с соответствующим образом увеличенным программным счетчиком инициатора, чтобы пропустить инструкцию вызова метода. 
Затем выполнение обычно продолжается в frame вызывающего метода с возвращенным значением (если оно есть), помещаемым в стек операндов этого frame.</p>
<p><strong>Резкое завершение вызова метода</strong></p>
<p>Вызов метода завершается преждевременно, если при выполнении инструкции JVM в методе выдает исключение, и это исключение не обрабатывается в методе.
Выполнение команды <strong>athrow</strong> также приводит к явному выбрасыванию исключения, и, если исключение не перехватывается текущим методом, 
приводит к неожиданному завершению вызова метода. Вызов метода, который завершается внезапно, никогда не возвращает значение своему вызывающему.</p>
<p><a href="#jvm">к оглавлению</a></p>
<h3 id="execution-engine"><a name="Execution-Engine"></a>Execution Engine</h3>
<p>Байт-код, назначенный <strong>run-time data areas</strong>, будет выполнен <strong>execution engine</strong>. Механизм выполнения считывает байт-код и выполняет его по частям.</p>
<p><strong>Interpreter</strong></p>
<p>Интерпретатор интерпретирует байт-код быстро, но выполняется медленно. Недостаток интерпретатора заключается в том, что, когда один метод вызывается несколько раз, каждый раз требуется новая интерпретация.</p>
<p><strong>JIT Compiler</strong></p>
<p>JIT-компилятор устраняет недостатки интерпретатора. Механизм выполнения будет использовать помощь интерпретатора при преобразовании байт-кода, 
но когда он находит повторный код, он использует JIT-компилятор, который компилирует весь байт-код и изменяет его на собственный код. 
Этот нативный код будет использоваться непосредственно для повторных вызовов методов, которые улучшают производительность системы.</p>
<ul>
<li>Генератор промежуточного кода (Intermediate Code Generator). Производит промежуточный код.</li>
<li>Code Optimizer. Отвечает за оптимизацию промежуточного кода, сгенерированного выше.</li>
<li>Генератор целевого кода (Target Code Generator). Отвечает за генерацию машинного кода или родной код.</li>
<li>Профилировщик (Profiler). Специальный компонент, отвечающий за поиск горячих точек, то есть, вызывается ли метод несколько раз или нет.</li>
</ul>
<p><strong>Garbage Collector</strong></p>
<p><a href="#jvm">к оглавлению</a></p>
<h3 id="_2"><a name="Полезные-ссылки"></a>Полезные ссылки:</h3>
<ul>
<li>https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html</li>
<li>https://www.developer.com/java/data/understanding-the-jvm-architecture.html</li>
<li>https://dzone.com/articles/understanding-jvm-internals</li>
</ul>
<p><a href="#jvm">к оглавлению</a></p>  </div>
</article>

    <footer>
<p>&copy;  </p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Java Interview ",
  "url" : "",
  "image": "",
  "description": ""
}
</script>

    <script>
      $(document).ready(function() {
        $('#tipue_search_input').tipuesearch();
      });
    </script>

</body>
</html>